<https://blog.csdn.net/SnailMann/article/details/88299127>

<https://www.huaweicloud.com/articles/f571bafcbe55475cd94d1f2f65e729a9.html> 幻读

mysql 读数据

当前读：

加锁保证其他事务不能修改当前数据。select for update

快照读：

生成一份快照。依赖于innodb对表建的隐藏字段，1\. 当前数据最近修改的事务id，2.回滚id。维护当前活跃的事务id 列表。

过程：取出最新修改数据的事务id，与当前系统活跃的事务id列表进行比较。如果，最新修改数据的事务id小于当前活跃的事务id中的最小的，说明数据未被其他事务修改，当前事务可见。

如果，最新修改数据的事务id\>=当前活跃最小id，那么当前数据对当前事务不可见。根据数据的回滚id，去undolog中查询合条件的数据；

undo log 中的数据依旧重复上面的逻辑直到找到合适的数据。因为，当前活跃的事务已经对该数据进行多次修改。

读未提交：

每次读都是当前读，保证数据是最新的。所以会出现脏读/不可重复读/幻读。

读提交：

同一事务中的每次读，都是快照读，重新生成一份快照。快照可以避免读到未提交的数据，但是不能解决不可重复读问题。

可重复读：

同一事务的读取数据，在首次读取时生成一份快照。之后的每次读都从快照中读取数据，所以可以避免不可重复读问题。但是不能解决幻读问题：

幻读问题：事务A 开启事务，进行执行select数据，查出数据为空，准备插入数据。此时，事务B插入同样数据，并提交事务，造成事务A插入失败。幻读 只针对 插入操作

解决幻读问题：

select \* from tale lock in share mode；

间隙锁 与 行锁：

id 有 1，5，7，10

事务A 读取 id = 3。此时，会触发间隙锁，锁住 1~5 之间的空间，此时，另外的事务想要插入 id = 3 id =4 之类的数据，都会被阻塞。