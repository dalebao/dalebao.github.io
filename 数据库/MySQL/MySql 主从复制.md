复制过程
----

1. slave 链接到 master，并告知 master 本次要请求的日志文件与位置。
  1. 请求 某个日志文件 某位置之后的内容；
2. Master 接收到请求之后，负责复制的线程将数据内容返回给slave。
  1. 同时包括，本次返回信息所在日志文件的名称及位置。
3. slave 接收到信息之后，将数据写入 relay 日志。顺序写入，尾部写入。
  1. 同时，记录本次信息在 master 的日志文件名称及位置。
4. slave 的线程检测到 relay log 有新的内容，进行解析，将数据写入 slave 数据库。

### 为什么需要 relay 日志

relay 日志 与 bin log 没有太大区别。假设，在复制过程中没有 relay 日志，在 master 将数据返回给 slave 之后，需要等待 slave 将数据写入到数据库，才算复制完成。此时，才能发送下一个 数据。相当于，master 给 slave 发送数据被阻塞住了。引入 relay 日志，我们可以认为 relay 日志写入之后，即是复制成功，可以继续下一个 数据 的发送。

### 有多少种线程

1. master binlog dump 线程，发送binlog给从服务器，一个从服务器一个
2. slave io thread & sql 线程
  1. io thread 将主库的binlog 写入relay log
  2. sql thread 将relay log 写入binlog 可能多线程

复制模型
----

1. 一主多从

这是最简单的模型，特别适合少量写、大量读的情况。读请求被分到了各个从库上，有效的帮主库分散了压力，能够提升读并发。当然，你也可以只是把从库当成一个灾备库，除了主从复制之外，没有其他任何的请求和数据传输。

1. 联级复制

当一主多从的模式，在有n个从库的情况下，主库中会有n个线程进行数据的 binlog dump。n 太大，会造成主库的抖动。

![](resources/CF7350531057123DDA40475E4EF764D3)

复制情况如上图：

  1. A 是主库，负责写入
  2. B、C 是 A 的从库
  3. D、E 是 B 的从库，F、G 是 C 的从库

较从库只从自己的主库读取数据，可以减少 A 主库的复制压力。但是，当上层出现问题之后，会影响到挂载在它下面的所有从库。且，复制链路越长，数据的延迟（不一致）情况越严重。

1. 主主复制

主库与主库进行复制，两台主库都可以进行写入。问题：主库与主库同时写入会造成数据的冲突。同时也会有循环更新问题：

###  主-主备份模式下的循环更新问题

客户端在节点A更新一条数据，生成binlog，然后将binlog发送给节点B，节点B更新完数据之后也会生成binlog，由于节点A也是节点B的备库，所以会将binlog发送给节点A，于是会发生循环更新的问题。

解决方案：

两个节点的serverid不能相同，如果相同不能互为主备。

在binlog中记录命令第一次执行的serverid，如果serverid相同就不执行。

于是，节点A执行的命令生成binlog记录的都是节点A的serverid，同步到节点B之后，将数据传输给节点Abinlog记录的也是节点A的serverid，当binlog回到节点A之后，节点A判断binlog的serverid与自己的相同则不执行。

主主复制更多的作用在与 HA。而不是写入的横向扩展。

###  使用 主主复制 进行不停服务的锁表更新

有时候，我们需要对数据库进行一些更新，这些更新可能是一些锁表操作，或者负载比较大的操作。此时可以选用 主主复制 进行。

  1. 有两台进行 主主复制 的 server，A 与 B。
    1. 其中 A 正常对外提供写能力，B 只提供读能力，不提供写能力。
  2. 将 A 从 relay 日志 中读取数据到数据库的线程停掉。意味着，A 依旧从 B 获取数据不一致的内容，但是不将数据写入到数据库卡。
  3. 此时，在 B 上执行一些耗时锁表操作。此时，A 上修改的数据依旧会被同步到 B 上。
    1. 当 B 执行完维护操作之后，会将改变同步到 A 的 relay log 中，但是 A 不会执行。
  4. 切换 B 到读写能力，A 切换到只有读能力。
    1. 此时对外提供写能力的服务器是 B。
    2. A 恢复从 relay log 中读取数据到数据库的能力。即时，操作再耗时，但是好在A不对外提供写的能力。

以上，就是使用 主主复制 模式保障 MySQL server 的高可用（HA）

复制模式
----

1. 异步复制

主库等待从库连接上来，发起复制请求。主库在将事务执行完之后，就会立刻返回，不会理会从库的复制情况。即：主库的写入，与从库的复制完成异步。

1. 同步复制

主库在执行一个事务，commit 之后，必须等待所有从库都确认之后才会返回给客户端。其中，commit 之后，主库直接提交事务，然后等待从库的复制结果。

如果，从库较多，同步复制明显会在客户端视角下，拖慢事务的执行时间。

1. 半同步复制

半同步复制，只需要一个slave确认返回即可返回给客户端。如果，规定时间内没有slave返回，那会切换成异步复制，再提交。客户端不需要一直等待下去。

至少保证一个从库节点可用。

复制中的数据一致性
---------