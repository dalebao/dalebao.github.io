## SDS

1. sds 的定义

```c
/*
 * 保存字符串对象的结构
 */
struct sdshdr {

    // buf 中已占用空间的长度
    int len;

    // buf 中剩余可用空间的长度
    int free;

    // 数据空间
    char buf[];
};
// ps: 在redis 3.0中  为了更加节省内存，可用的sdshdr分成4种，len和free属性分别可以是uint8_t，uint16_t，uint32_t，uint64_t 这四种类型，会随着sds所保存的字符串长度不同，而分配为不同的sdshdr。 获取长度；

```

2. 使用 SDS 的好处

-     获取长度时间复杂度为O(1)，c 语言的为 O(n)
-     缓冲区不会溢出，字符串修改时，会先根据len判断长度，然后进行扩容,减少字符串的内存重新分配次数，由于free与len的存在可以优化空间分配
-     空间预分配：扩展时，实际分配的空间大于需要的空间
-     惰性空间分配：字符串缩短时，使用free记录空余空间，等待后续使用
-     二进制安全：使用数组存放数据，可以兼容二进制文件中的一个空格。（C语言字符串使用空格结尾，无法兼容）
-     兼容部分C字符串函数

## 链表

redis 的链表时双向无端链表，两头皆指向 null，取头尾时间复杂度结尾 O(1)。内部含有 len 变量，取长度时间复杂度为 O(1)。

## 字典

    使用数组存储数据，使用拉链法解决hash冲突。hash计算与HashMap中相同为，hash(key)&(cap-1)。扩容操作也基本与HashMap相同，扩容到两倍大小，然后rehash放置。

扩容条件：

-     没有bgsave或者bgwirteaof 且 负载因子大于
-     正在执行 bgsave 或者 bgwriteaof 且负载因子大于5

> 负载因子=hash 表已保存数量/hash 表大小。

渐进式扩容：当数据量比较大时，扩容是渐进的分多次完成的，不是一次性完成的（原因，扩容比较耗时，为了 hash 能提供服务）。在渐进扩容时，redis 的操作可能发生在两个键上。
新增操作，一定是在第二个 hash 键上
查询、更新、删除操作，会在原键上查询，找不到再去第二个键上查询。

## 跳跃表

有序链表，查询体现二分法思想，每个节点维护多个指向其他节点的指针。

特点如下：

- 由多层结构组成
- 每一层都是有序链表，排列顺序由高层到底层，每层至少包含两个指针，指向头（head）尾（null）
- 最底层包含所有元素
- 高层链表是底层链表的子集。一个元素出现在某一层中，那该层以下的每一层都会出现该元素
- 每个节点都有两个指针，一个指向同一层的下一个元素，一个指向下一层的同一个元素

各种操作逻辑：

- **查询**：从最高层开始，如果比当前节点大，比下一个节点小，就往下查询（与下一层的下一个节点比较）。
- **插入**：确定插入层数，投硬币法，正面层数加 1，反面结束逻辑。
- **删除**：在各层中寻找该值，然后删除。当某一层只剩下头尾两个节点时，删除该层

## 整数集合（intset）

由一个整数数组来保存数据，数据按照升序从小到大排序，保证不出现任何重复项。
