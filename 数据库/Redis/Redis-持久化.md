## RDB 持久化

rdb 持久化是生成一个二进制的文件，该文件保存的是某一时刻redis内存中的所有数据。

### 优势

1. **rdb** 会生成一个紧凑的二进制文件，保存某一时刻的全量数据，可用于灾备与恢复。
2. 生成rdb文件的时候，fork一个子进程，主进程可以继续处理请求，<u>主进程不会进行io操作</u>。
3. rdb在大量数据恢复速度上比aof更快。

### 劣势：

1. 不能做到实时备份，数据丢失可能性更大。
2. fork一个子进程进行操作，如果没有压缩算法，内存会膨胀一倍，频繁操作会影响性能。
3. 版本兼容性差。

### 命令：

1. **save 命令** 阻塞主进程，此时主进程不能处理命令
2. **bgsave 命令** fork一个子进程，子进程共享进程fork出来那一瞬间的内存（快照实现），遍历内存且进行rdb文件写入。此时父进程对内存进行修改，会将要修改的那一个页面复制出来（内存膨胀原因），进行修改。子进程的内存依旧没变。

#### 触发：
1. 手动触发（save、bgsave）
2. 自动触发 配置 save m n；表示 m 秒钟 操作 n 次就执行一次 bgsave

**自动触发的原理**：
依赖于 **dirtycount** 与 **lastsave** 实现

1. dirtycount：记录上一次保存之后，发送的命令操作数，例如，sadd key val1 val2 val3 -> dirty+=3
2. lastsave：记录上一次保存触发的时间

通过定时器 saveCron 函数，依次判断所有 save m n， 有一个满足就触发，执行之后更新lastsave，且把dirtycount 置为0；

## AOF 持久化
aof 是将redis接收到的命令，顺序的写入到aof文件中。

### 优势

1. 提供多种同步策略，在每秒刷盘一次的配置下，最多丢失一秒的数据。
2. 使用追加命令的方式写入。
3. 可读性较强，在误操作 比如 flushall 的情况下，且没有文件重写，可以手动删除命令，恢复数据。

### 缺点

1. 相对于 rdb 文件通常较大
2. 在负载高的情况下，aof 会产生更多的文件io，rdb的性能更好

#### 持久化策略

- **no** 不执行 fsync，由操作系统保证，宕机丢消息概率大
- **always** 每次写入都fsync，io负载更高
- **everysec** 每秒写入一次，最多丢失一秒的数据

### 文件重写：
Aof是追加的模式，随着时间推移，文件会越来越大。所以需要文件重写来处理文件过大的问题。当aof文件大小超过阈值时（**auto-aof-rewrite-percentage**和**auto-aof-rewrite-min-size**），触发文件重写。文件重写，**并不是对文件进行整理，而是重新读取内存中的数据，重新生成一个文件替换原来的aof文件**。

#### 文件重写时会发生fsync吗？

可通过参数（**no-appendfsync-on-rewrite**）设置在重写时是否可以fsync。允许fync的时候，可以保证数据一致性，但是会造成更高的负载。不允许时，可能会丢失一部分数据（操作系统自动fysnc时间是30s一次）

#### 文件重写时，是阻塞的吗?

bgwriteaof不是，类似于rdb，会fork一个子进程进行操作，这样主进程就可以继续处理请求了。主进程在fork一个子进程进行文件重写的时候，会设置一个 **aof 重写缓冲区，fork之后的命令都会放在缓冲区中，子进程完成文件重写之后，主进程会将缓冲区的文件写入到新的aof文件中**。

#### 如何更好的处理文件重写？

关闭自动触发，在系统闲时使用命令触发，比如：系统定时任务触发 bgwriteaof