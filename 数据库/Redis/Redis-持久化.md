## RDB 持久化

rdb 持久化是生成一个二进制的文件，该文件保存的是某一时刻 redis 内存中的所有数据。

### 优势

1. **rdb** 会生成一个紧凑的二进制文件，保存某一时刻的全量数据，可用于灾备与恢复。
2. 生成 rdb 文件的时候，fork 一个子进程，主进程可以继续处理请求，<u>主进程不会进行 io 操作</u>。
3. rdb 在大量数据恢复速度上比 aof 更快。

### 劣势：

1. 不能做到实时备份，数据丢失可能性更大。
2. fork 一个子进程进行操作，如果没有压缩算法，内存会膨胀一倍，频繁操作会影响性能。
3. 版本兼容性差。

### 命令：

1. **save 命令** 阻塞主进程，此时主进程不能处理命令
2. **bgsave 命令** fork 一个子进程，子进程共享进程 fork 出来那一瞬间的内存（快照实现），遍历内存且进行 rdb 文件写入。此时父进程对内存进行修改，会将要修改的那一个页面复制出来（内存膨胀原因），进行修改。子进程的内存依旧没变。

#### 触发：

1. 手动触发（save、bgsave）
2. 自动触发 配置 save m n；表示 m 秒钟 操作 n 次就执行一次 bgsave

**自动触发的原理**：
依赖于 **dirtycount** 与 **lastsave** 实现

1. dirtycount：记录上一次保存之后，发送的命令操作数，例如，sadd key val1 val2 val3 -> dirty+=3
2. lastsave：记录上一次保存触发的时间

通过定时器 saveCron 函数，依次判断所有 save m n， 有一个满足就触发，执行之后更新 lastsave，且把 dirtycount 置为 0；

## AOF 持久化

aof 是将 redis 接收到的命令，顺序的写入到 aof 文件中。

### 优势

1. 提供多种同步策略，在每秒刷盘一次的配置下，最多丢失一秒的数据。
2. 使用追加命令的方式写入。
3. 可读性较强，在误操作 比如 flushall 的情况下，且没有文件重写，可以手动删除命令，恢复数据。

### 缺点

1. 相对于 rdb 文件通常较大
2. 在负载高的情况下，aof 会产生更多的文件 io，rdb 的性能更好

#### 持久化策略

- **no** 不执行 fsync，由操作系统保证，宕机丢消息概率大
- **always** 每次写入都 fsync，io 负载更高
- **everysec** 每秒写入一次，最多丢失一秒的数据

### 文件重写：

Aof 是追加的模式，随着时间推移，文件会越来越大。所以需要文件重写来处理文件过大的问题。当 aof 文件大小超过阈值时（**auto-aof-rewrite-percentage**和**auto-aof-rewrite-min-size**），触发文件重写。文件重写，**并不是对文件进行整理，而是重新读取内存中的数据，重新生成一个文件替换原来的 aof 文件**。

#### 文件重写时会发生 fsync 吗？

可通过参数（**no-appendfsync-on-rewrite**）设置在重写时是否可以 fsync。允许 fync 的时候，可以保证数据一致性，但是会造成更高的负载。不允许时，可能会丢失一部分数据（操作系统自动 fysnc 时间是 30s 一次）

#### 文件重写时，是阻塞的吗?

bgwriteaof 不是，类似于 rdb，会 fork 一个子进程进行操作，这样主进程就可以继续处理请求了。主进程在 fork 一个子进程进行文件重写的时候，会设置一个 **aof 重写缓冲区，fork 之后的命令都会放在缓冲区中，子进程完成文件重写之后，主进程会将缓冲区的文件写入到新的 aof 文件中**。

#### 如何更好的处理文件重写？

关闭自动触发，在系统闲时使用命令触发，比如：系统定时任务触发 bgwriteaof
