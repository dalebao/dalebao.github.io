- 分布式事务
	- 二阶段提交
	    - 内容
	        -  1. 事务协调器询问各个业务是否就绪
            - 2. 事务协调器负责各个业务的提交与回滚
        - 优点
	        - 基本所有商业化数据库都支持 XA 协议的二阶段提交
        - 缺点
	        - 1. 开发复杂
            - 2. 锁定资源时间长
            - 3. 对性能影响大，不适合微服务场景
    - tcc
	    - 内容
	        - 1. 将操作分为 try confirm cancel
            - 2. try 对业务系统做检测及资源预留
            - 3. confirm 对业务系统做提交确认，默认confirm 不会出错，try 成功 confirm 一定成功
            - 4. cancel 阶段在需要回滚的状态下 执行业务取消
        - 流程
	        - 1. 业务应用向 事务协调器 发起开始事务的请求 try 阶段
			- 1.1 业务应用 按照 try 的返回结果，告诉事务协调器应该 confirm 或者 cancel
            - 2. 事务协调器 向所有业务发起confirm 提交改变或者 cancel 回滚
        - 缺点
	        - 很多逻辑都需要自己实现，复杂且开发量大
    - 本地消息表
	    - 内容
	        - 一个本地消息表，记录事务的相关信息，如id 类型 重试次数等
			- 需要一个mq，作为业务之间的通信，不一定是 mq 也可以是其他中间件
        - 流程
	        - 1. A 系统在本地进行一个事务操作的同时，向消息表中插入一条消息
            - 2. 然后将消息写入 mq
            - 3. B 系统接收到消息，执行事务的同时，也写一条消息到本地的消息表，如果消息已经处理过了，那么不会执行之后的操作，保证消息不会重复消费
            - 4. B 系统成功之后，更新自己的消息表，然后更新 A 系统的消息表
            - 5. 如果失败了，由 A 系统扫描自己消息表的状态，然后重试。
        - 缺点
	        - 严重依赖数据库，且扩展性不好
            - 使用异步来保证一致性，会有分区容错性问题
    - RocketMq 事务消息
	    - 内容
	        - 使用 rocketMq 的事务消息来实现分布式事务
        - 流程
	        - 1. A 系统发送 prepared 消息到mq，如果发送失败则取消任务
            - 2. 如果发送成功，则继续本地事务，成功之后告诉mq 确认，失败则告诉回滚
            - 3. 如果 mq 收到确认消息，那B系统就会收到消息，然后执行本地事务。
            - 4. Mq 会定时轮询会有 prepared 消息，然后回调 B 系统接口，询问事务是否完成，是选择重试或者是回滚
            - 5. 如果B系统失败了，可以选择不断重试，也可以选择通知A系统进行回滚。
        - 缺点
	        - 实现难度大，且主流mq不支持
    -   LCN
	    - 内容
	        - 1. 创建事务组：事务发起方在执行事务前，先请求 txManager 创建事务组，拿到groupId
            -   2. 添加事务组：事务参与方在完成事务之后，将信息提交给 txManager 进行添加
            -   3. 关闭事务组：事务发起方在事务执行完之后，将执行结果告知 txManager，由txManager通知业务参与方进行事务提交或者回滚

**参考：**

[参考1](https://www.cnblogs.com/mayundalao/p/11798502.html)

[参考2](https://www.cnblogs.com/jing99/p/11769093.html)