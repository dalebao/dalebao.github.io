阻塞io
----

读写数据时发生阻塞。当用户线程发出io请求之后，内核会去查看数据是否准备就绪，如果准备就绪就返回，如果没有就阻塞，此时用户线程会交出cpu。

数据准备就绪之后，内核会将数据拷贝到用户线程，并将数据返回。

非阻塞io
-----

用户线程发起一个io请求之后，会马上得到一个返回结果。如果是error，那么可以再次发起一个io请求。如果数据准备就绪，内核会将数据拷贝到用户线程中。

实际上，非阻塞io是不断的发起io请求检查数据是否准备就绪，因此，cpu占用会很高。

多路复用io
------

java nio 就是多路复用io。

有一个线程不断的轮询查询多个socket的状态，只有当socket真的有读写状态时，才会发生io的读写。

重点：

1. 一个线程管理多个socket
2. 通过轮询的方式检查socket，并且顺序处理socket的读写，当某个socket的读写事件很大时，会印象其他的socket。

事件驱动io
------

在事件驱动io中，用户线程发起一个io请求，会给对应的socket注册一个信号函数，然后用户线程继续执行。

当内核将数据准备就绪之后，会发送一个事件给用户线程，用户线程接收到事件之后，便在事件函数中调用io读写操作来进行实际的io读写操作。

异步io
----

用户线程在发起一个io读请求时，会给内核发送一个 read 请求，之后去做其他的事情。

内核收到 read 请求，立马返回，表示已经收到了该 请求。

在数据准备好之后，内核会将数据拷贝到用户线程，并且发送一个信号给用户线程，通知 io 读 操作已经完成。

用户线程直接使用数据即可。

### 异步io与事件io的区别

1. 事件驱动io在收到io完成事件之后，需要调用io函数进行真正的io读写。
2. 异步io中的用户线程在收到io完成之后，直接使用数据，不需要调用io函数。

Java NIO
--------

NIO 中的几个概念：

1. buffer 缓冲区，数据的中间容器
2. selector 用于监听多个chennel
3. channel 双向io流，可以用于读和写

selector 可以监听多个 channel 是否有读写时间发生，如果有事件发生，针对事件进行对应的处理。

select & poll & epoll
---------------------

select 缺点：

1. 需要维护一个存放大量fd的数据结构，使得用户空间和内核空间之间的复制开销变大。
2. 支持的文件描述符数量太小，只有1024个。
3. 主动轮询效率慢。

poll ：

poll 没有最大文件描述符的数量限制。引基于链表存储。

1. 依旧需要在用户空间和内核空间进行复制，开销很大。
2. 大量的fd会复制与用户空间和内核空间，不管其是否有意义。

epoll：

1. epoll 基于事件驱动，事件绑定fd。
2. 没有最大文件描述符数量限制。
3. 效率提升，不是轮询，不会因为fd数量增加而降低效率。
4. 内存拷贝，用户空间与内核用户内存共享实现，不需要付出复制的开销。
5. 改主动轮询为被动轮询。

select 和 poll 都需要不断轮询所有fd集合，直到设备就绪，中间可能需要唤醒/睡眠多次。

epoll 有两种触发模式：

水平触发（LT）：只要该fd还有数据可读，每次 epoll\_wait() 都会返回他的事件，提示用户去处理。

边缘触发（ET）：只会提示一次，直到下次再有数据流入之前都不会再提示，无论fd是否有数据未读。

缺点：

1. 在fd数量较少，且都比较活跃的情况下，效率不如 select，因为epoll的通知机制有很多回调函数。
2. select 一般操作系统都有，而epoll是linux特有的。

零拷贝
---