如何实现接口的幂等性
==========

会产生的问题
------

1. 重复调用订单接口生成两个订单
2. 重复调用扣费接口多次扣费

接口的幂等性实际上就是接口可重复调用，在调用多次的情况下，接口得到的结果是一致的。简单来说，就是不能因为多次调用改变接口调用后对数据的影响。

操作表去重
-----

使用一个操作表，记录已经进行过的操作，然后进行去重。比如：mq的重复消费wenti问题。

使用操作表去重，我们需要每个操作都有一个唯一操作id，这样我们可以在依赖这个唯一的操作id进行判断。

if(select\_from\_db(operate\_id)){ // 已存在操作 return; } // 未存在操作

以上代码，已存在操作表示已经执行过，不需要再执行。

但是在多线程情况下，可能存在两个线程同时查询db的同一条数据，导致重复执行。所以以上代码应该加上锁，或者分布式锁。

加锁的操作可以保证数据与操作的原子性，但是大大降低了并发度。

此时，可以考虑一下代码。

if(insert(operate\_id)){ // 插入成功，第一次操作 return; } // 插入失败，已经操作过

以上代码，利用了数据库里的唯一键，数据库可以保证数据的唯一性，同时插入两条相同数据的时候，会因为主键（或者）冲突而失败。

重试机制，如果操作失败，可以选择将数据再次放入消息队列。

token 机制
--------

用于api层面的幂等，保证请求只会请求一次。

1. 调用方先向服务方请求一个唯一token
2. 服务方将token存储下来
3. 调用方在请求服务时，带上token
4. 服务方判断token是否存在
  1. 存在，则正常处理，结束后删除token
  2. 不存在，表面请求异常
5. 正常处理之后，服务方更换token给调用方，用于下次请求

以上流程，需要一个唯一token，可以使用 redis 的自增 来实现，也可以使用 雪花算法生成 唯一ID

### 雪花算法

使用一个 64 bit 的 long 型的数字作为全局唯一 id。

这 64 个 bit 中，其中 1 个 bit 是不用的，然后用其中的 41 bit 作为毫秒数，用 10 bit 作为工作机器 id，12 bit 作为序列号。

缺点： 依赖于服务器之间的时钟同步

## 其他办法

### 版本号

对于需要版本控制的数据，可以考虑使用版本号进行管理。

在数据中增加一个字段，记录操作的版本号。

冲突的解决：

1. 可以交给前端解决。
2. 按照策略解决，比如：选择版本号的数据。

### 状态机

更新数据时，判断状态。状态不对时，不进行更新。