[参考文章1](https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/multi-thread/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93.md#432-execute-vs-submit)
================================================================================================================================================================================

[参考文章2](https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html)
=================================================================================

线程池参数
=====

* corePoolSize 核心线程池数量
* maxPoolSize 最大线程池数量
* keepAliveTime 保活时间
* ThreadFactory 创建线程工厂
* TaskQueue 保存任务的阻塞队列

线程提交任务
------

execute() 与 submit()

区别：

1. execute 执行任务，没有返回值
2. submit 执行任务，有返回值，Future对象。可以根据该对象判断任务的状态（成功、取消、返回值）

submit 封装任务到Feture对象，然后调用execute 执行任务。

### execute 流程

1. 塞入任务，当前活跃线程未超过 corePoolSize 时，调用addWorker创建线程，执行任务
2. 当活跃线程超过corePoolSize，此时任务阻塞队列并未满时
  1. 判断线程池是否shutdown，如果没有就将任务塞到任务队列中
  2. 再次检查线程池是否running，如果非running 就将任务移除，并且触发拒绝策略。如果当前活跃线程数量为0，则创建新的线程。（为什么要doublecheck：因为活跃的线程可能在上次检查完之后死掉）
3. 如果线程池处于非running或者阻塞队列不能offer任务，此时再尝试创建一个新的worker，如果失败触发拒绝策略
  1. 此时addWorker，表明corePoolSize的线程已经创建完成，且任务阻塞队列也已经满了，于是继续创建线程直到 maxPoolSize。

### addWorker 流程

1. 判断当前线程池的状态是否允许addWorker
  1. 当前线程池状态大于shutdown（shutdown\<stop\<tidying\<terminated）或者 ... 不允许
  2. 当前活跃线程数大于最大值（corepoolSize 或者 maxPoolSize 或者..）不允许
  3. cas 增加活跃线程数，允许
2. new Worker类，将对象塞到workerQueue中
3. 如果workerQueue塞入成功，调用worker.thread.satrt() 直接开始执行线程第一个任务。

### Worker 执行任务流程

worker.thread.start() 方法其实执行的是 worker的run方法

在一个while循环里从taskQueue中获取task来执行。

1. worker对象加锁（为什么？什么场景会有线程安全问题 <https://www.cnblogs.com/thisiswhy/p/15493027.html> ）
  1. workers 使用的对象是hashset 非线程安全set
  2. largestPoolSize 保证获取时是安全合理的数据
  3. 假设多个线程同时调用 shutdown，会尝试关闭活跃线程，如果没有锁，就会导致中断风暴，已终端的线程触发中断
2. 执行前先判断线程池是否处于关闭过程中。保证在关闭线程池所有的线程都会被中断。
3. 当没有任务队列中没有任务之后，执行worker退出
  1. 从workerQueue中删除当前worker
  2. 尝试terminate线程池
  3. 如果线程池执行状态小于stop（还在运行）且活跃线程数已经小于最小值了（最小值默认是corePoolSize大小，如果设置 allowCoreThreadTimeOut则可以降为 1），尝试重新创建一个worker

### 如果长时间没有task，线程会如何处理？

线程长时间获取不到task会触发销毁线程的操作，此时 keepAliveTime起到了作用。

由worker执行任务的流程可以得知，当getTask失败之后 会执行退出线程的操作。

1. 当工作线程大于corePoolSize时，从taskQueue中阻塞的获取task，时间为 keepAliveTime，超时返回null，退出线程。
2. 当工作线程小于corePoolSize时，使用take从taskQueue中获取task，获取的task为null，则退出线程。

### 

### 线程池销毁

shutdown（）:

1. 线程池状态被设置为 SHUTDOWN
2. 不再接收新的任务，但是会将taskQueue中的任务执行完（如何做到？）
  1. worker 继承 aqs，调用 interruptIdelWorkers时会先上锁检查执行状态
  2. 如果已经获取到 task，那么上锁失败。

shutdownNow()：

1. 线程池状态被设置为STOP
2. 不再接受新任务，taskQueue中的任务也不再执行，将任务返回给调用线程

当线程池的线程都被中断后，调用tryTerminate，将线程池设置为TIDYING。然后执行钩子 terminated 关闭线程池。

### 任务拒绝

何时任务拒绝：

1. 线程池处于非 RUNNING 状态，调用了shutdown shutdownNow
2. 线程池中活跃线程数大于 maxPoolSize 且 taskQueue 已经满了

有哪些拒绝策略：

1. 默认：丢弃任务，抛出异常
2. 丢弃任务，不抛弃异常
3. 丢弃最老的任务，执行当前任务
4. 使用调用者线程来处理任务

### 线程池如何保证任务不丢失

使用submit提交任务，接收到任务执行的结果。