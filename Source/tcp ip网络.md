[tcp 三次握手/四次挥手](https://blog.csdn.net/qzcsu/article/details/72861891)

[tcp/ip](https://snailclimb.gitee.io/javaguide/#/docs/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C?id=_21-tcp-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E6%BC%AB%E7%94%BB%E5%9B%BE%E8%A7%A3)

三次握手过程？
=======

1. 服务端创建传输控制窗口，进入listen状态。
2. 客户端创建传输控制窗口，准备连接状态，发送 SYN=1 到tcp服务端 此时，本次发送序列号（seq） 为 x
3. 服务端接收到 SYN = 1，允许连接，应答 SYN=1/ACK=1 允许连接，此时 本次发送序列号（seq）为 y ，确认号（ack）为 x + 1
4. 客户端接收到消息，发送 ACK=1，本次发送序列号（seq）为x+1，确认号（ack）为y+1
5. 连接建立

序列号（seq）与确认号（ack）
=================

tcp传输中，字节流的每个字节都有序号（seq），假设本次传输的字节流的第一个字段序号为x，且总共有y个字节，那么，下次要传输的字节流的序号应该是从x+y开始。

确认号（ack），是期望下一次客户端发送的字节流的第一个序号值，例如，本次收到的字节流的首字节序号为x，长度为y，如果正确收到了字节流，那么通知客户端，下一次传输的字节流的首个序号为 x+y+1

为什么需要第三次握手？

假设两次握手即可完成连接。

第一次连接发送请求，遇到网络延迟。

第二次连接发送请求，服务端接收到请求，返回ack，建立连接。

当第二次的请求建立的连接结束之后，收到了第一次发出的请求。此时服务端再进行返回ack就会建立错误连接。

如果是三次握手，就算收到了错误的请求，也返回了SYN=1，ACK=1，但是服务端不会受到客户端第三次握手的请求，也不会建立连接；

四次挥手过程？

1. 客户端主动发起断开连接，发送FIN=1 序号（seq）为x 发送给服务端
2. 服务端接收到之后，返回ACK =1 ，ack=x+1，seq=y，告诉客户端已经收到断开连接请求。
3. 服务端在将需要发送的消息发送给客户端之后，发送 FIN=1 ACK=1 ack=x+1 seq=w,告诉客户端已经可以断开连接了。
4. 客户端接收到消息之后，发送ACK=1，seq=x+1,ack=w+1给服务端，服务端断开连接进入CLOSED
5. 客户端等待2MSL（最长报文生命周期）之后，没有新的报文，关闭连接。

为什么需要四次挥手？

1. 在服务端第一次返回ACK之后，可能还存在需要传输给客户端的数据，此时需要等待服务端先下发消息给客户端。传输完之后，再发送一次FIN=1，ACK=1给客户端。
2. 可以认为是分别是客户端和服务端的确认关闭过程
  1. 第一次 客户端向服务端 挥手，客户端向服务端明确，自己可以关闭。
  2. 第二次 服务端向客户端 挥手，服务端向客户端告知，允许你关闭，但是等一下我还有消息需要给你。
  3. 第三次 服务端向客户端 挥手，服务端向客户端明确，我这边消息已经发完了，可以关闭了。
  4. 第四次 客户端向服务端 挥手，客户端向服务端明确，客户端已经收到消息，你关闭吧。

为什么客户端最后需要等待2MSL
================

1. 在服务端发送最后一个挥手消息之后，需要接收到客户端的ACK才能关闭客户端，但是客户端发出的请求可能丢失，会触发重试机制。而客户端可以在这个2MSL的时间内接收到该消息，然后重新开始计数2MSL。
2. MSL等待时间是报文的最长生存时间，等待2MSL的时间，可以确保所有的消息都已经消失在网络中。

tcp 协议如何保证消息传递的可靠

1. 数据被分割成tcp认为最适合传输的数据块
2. tcp将每个包进行编号（seq），接收到对数据包进行排序，将有序的数据交给应用层
3. 校验和，在tcp报文首部有2个字节的大小保存数据的校验和，确保数据在传输过程中没有被篡改。如果不对将会被丢弃，且不发送收到的ack。
4. 接收端会丢弃重复的数据。
5. 流量控制，利用滑动窗口控制发送方发送的数据是接收到能够处理的大小。
6. 拥塞控制，当发生网络拥塞时，减少数据的发送
7. APQ协议，每发送完一个分组，等待对方确认，然后再发送另外的分组。
8. 超时重试机制，没发出一个段，就会启动一个定时器，等待接收对方发出的ack。如果超时不能收到，就重新发送

tcp的滑动窗口

tcp将数据进行分段，接收方在确认ack的报文首部中通知发送方需要将发送报文的大小设置成多大。以此达成控制发送方发送消息大小的效果。

[拥塞控制](https://blog.csdn.net/jtracydy/article/details/52366461)

tcp发送方需要维护一个 拥塞窗口 变量。tcp发送消息的大小取决于 发送方拥塞窗口大小 与 接收方滑动窗口 之间的最小值。

算法：

1. 慢开始：在发送方开始发送数据时，慢慢的将窗口变大。一开始为1，经过一次传播之后，将窗口翻倍。
2. 拥塞避免：在窗口大小达到一定阈值时，转换为拥塞避免，窗口的扩大速度降为一个传播轮次之后，窗口大小加1。
3. 快重传：接收方收到乱序的报文之后，立刻发出重复确认。例如，发送方发送m1,m2,m4,m5,m6，接收方在收到m4时，发现乱序，立马回复m2的重复确认ack。当接收方连续收到三次m2的确认通知时，发送方不必等待重传定时器，直接发送m3。
4. 快恢复：当发送方连续收到三个确认之后（假定消息丢失），减小拥塞窗口大小。

粘包与拆包
=====

1. 发送方发送的数据包大于接收方的缓冲区大小，会造成拆包
2. 发送的数据包小于缓冲区大小，网卡将数据多次写入数据包，造成粘包

解决：

1. 报文首部增加数据包的大小
2. 发送端固定发送包的大小，不够的以0补齐
3. 以特殊符号设置边界

https://www.cnblogs.com/limt/p/4205566.html