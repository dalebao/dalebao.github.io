限流方案
----

利用redis的原子计数器，统计固定时间范围内的数量

例如：全系统一秒只能有1000次请求

\# 这是 key 为 秒级 key = "system\_limit\#"+time.time(); \# 秒级时间戳 num = redis.incr(key) if num \> 1000: return "out of limit" else if num == 0: \# 第一次访问 redis.expire(key,2,seconds) return True else: return True

1. 指定聊天室，只需要把聊天室id加入到key里面。
2. 修改限制数量，例如一分钟限制数量，修改时间戳精度

写入/获取消息到redis数据库
----------------

采用redis zset 数据结构，利用发送消息时间戳作为score，消息体作为 item

\# redis 键中携带appId与聊天室Id key = "chatroom\_msg\_%s\_%s"%(appId,chatroomId) num = redis.zCard(key) if key \> 500: redis.zRemRangeByRank(0,num - 500) \# 删除 socore 最小的 n 个， redis.zAdd(key, timestamp, payload) \# 保持最多500 个消息 \# 获取 需要 appId 上一次获取的最大 timestamp（毫秒级） msgList = [] if timestamp == None: \# 第一次获取 msgList = redis.zRange(key, -20,-1) \# 取最新的20条 else: msgList = redis.zRangeByScore(key, timetamp, time.time(), "limit 0 -1") 

敏感词树存储
------

1. 敏感词树，需要每个业务方一颗树
2. 敏感词树属于读多写少业务

选用 CopyOnWriteHashMap 存储，键为appId，值为敏感词树。

隐患，使用CopyOnWriteHashMap 在写时，会有两份内存存储数据，当敏感词库比较大的时候，可能会造成频繁的GC

选用 ConcurrentHashMap 存储，键位appId，值为敏感词树

使用分段锁，默认情况下，最多支持16个线程同时操作，读时不需要进行加锁