无锁算法CAS
=======

ABA问题
-----

多线程情况下出现ABA问题：

线程1：期望A，欲修改为B

线程2：期望A，欲修改为B

线程2进行阻塞，线程1将内存中A变为B，此时线程3出现，期望B欲修改为A，修改完后，线程2恢复，再次将A修改为B。

线程2并不知道值已经从A变为B再变为A了。

解决方案：

1. 给变量加上版本号，线程A修改1A变为2B，线程3修改2B变为3A，此时线程2恢复拿着1A就不会修改成功了
2. 原子应用对象，atomrefrence

自旋cpu开销大
--------

如果修改不成功，cas要讲期望值换成内存中的最新值。

例如，原子累加时，如果失败要将期望值替换成最新值再次cas比较，自旋对cpu的开销很大。

只能保证一个变量的原子性
------------

Synchronized 原理
---------------

synchronized 是悲观锁，依赖于对象头中的数据与monitor实现

### 无锁

Cas实现无锁

### 偏向锁

在大多数情况下，一段同步代码都是一直由同一线程重复执行，那么该线程自动获取锁，降低获取锁的代价

实现：

当一个线程访问同步代码块获取锁时，会在MarkWord里存储对应的线程id。在线程进入和退出同步代码块的时候，不在通过cas操作来加锁和解锁，而是检测markword里是否存在指向当前线程的偏向锁

目的：

为了在无多线程竞争的情况下尽量减少不必要的轻量锁获取的执行路径。

释放：

偏向锁只有遇到别的线程尝试竞争偏向锁时，只有偏向锁的线程才会释放，偏向锁不会主动释放。需要等待全局安全点（在某个时间点上没有线程在执行）。它会先暂停持有锁的线程，然后判断锁对象是否处于锁定状态。

### 轻量级锁

当锁时偏向锁的时候，被其他线程竞争，锁会升级为轻量级锁，其他线程会通过自旋不断尝试获取锁，不会阻塞提高性能。

### 重量级锁

当自旋超过一定次数，或者一个线程在持有锁，一个在自旋，又来一个线程竞争锁，轻量级锁升级为重量级锁。此时其他线程进行阻塞等待。

偏向锁通过对比Mark Word解决加锁问题，避免执行CAS操作。而轻量级锁是通过用CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。重量级锁是将除了拥有锁的线程以外的线程都阻塞

公平锁与非公平锁
--------

公平锁通过同步队列来支持获取锁的顺序与申请锁的顺序相同

非公平锁直接尝试获取锁，所以有后申请锁的线程先获取锁的情况

可重入锁与非可重入锁
----------

可重入锁通过state记录当前线程重入次数。可以一定程度避免死锁问题。

AQS 详解
------

https://www.cnblogs.com/waterystone/p/4920797.html