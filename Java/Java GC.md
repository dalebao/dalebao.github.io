如何判断垃圾
------

### 引用计数

记录对象被引用次数，如果对象引用次数为0，则表示该对象应该准备被清除了。

会有循环引用的问题，导致对象无法被清理。

### 可达性分析

从GC ROOT开始，向下所有所有有引用的对象。当一个对象与GC ROOT 没有链路连接的时候，该对象为垃圾需要被清楚。

可作为GCROOT对象有以下四种：

1. 虚拟机栈中引用的对象（栈帧中的本地变量表）
2. 方法区中类静态属性引用的对象
3. 方法区中常量应用的对象
4. 本地方法栈中JNI引用的对象（Native 方法）

如何回收垃圾
------

1. 标记清除法：标记出需要整理的对象，然后将对象删除，容易产生内存碎片化的问题
2. 复制算法：将内存一分为二，将未标记为垃圾的对象移动到未使用的内存上，然后之前使用的内存清空，会造成内存使用率不高
3. 标记整理算法：将标记为垃圾的内存删除，然后将存活的内存向一侧移动。解决碎片化与内存利用率问题，但是会造成操作频繁的问题

java 堆空间的分配
-----------

分为 新生代与老年代

新生代分为 eden + 2个survivor

### Eden 触发垃圾回收

当eden区没有足够的空间存储对象时，会触发minorgc。将存活的对象移动到survivor from区，如果空间不够就直接存放到老年代。

### 为什么需要survivor区

survivor区是老年区的一个缓冲，因为大部分的对象，会在第一次minor gc 之后被消除，剩余存活的对象也会在两到三次minor gc 之后会消除。所以survivor存在的意义在于减少被送往老年区的对象，以减少majorgc的次数。

### 为什么需要两个survivor区

如果只有一个survivor区，当要清理垃圾的时候只能使用标记清除法，会产生内存碎片化的问题。如果有两个区，在发生minor gc 的时候，可以将eden区与from区的对象复制到to区，然后将to区的职责对from对掉。

可以保证survivor区永远有一块区域是空的，可以避免内存碎片化。

### 老年代

老年代占用着三分之二大小的堆，在进行major gc的时候会发生 stw。内存越大，stw越长。老年代采用的垃圾处理算法是整理算法。

老年代内含有的对象有

1. 大对象：当一个对象需要连续的大内存的时候，会直接进入老年代
2. 长期存活对象：当对象在survivor区移动，每移动一次年龄加1，当满15会被移动到老年代
3. 动态大龄对象：当survivor区相同年龄的对象大小总和达到survivor区大小的一半，年龄大于等于该年龄的对象都会进入到老年区