## 为什么需要多线程

为了均衡， cpu/内存/io设备之间的速度差异

* cpu 增加缓存，以均衡与内存的速度差异； // 导致 可见性 的问题（volatile）
* 操作系统增加了进程、线程，以分时复用cpu，以均衡cpu与io设备之间的速度差异；//导致 原子性 问题
* 编译程序优化指令执行次序，使得缓存能够得到更加合理的应用；// 导致 有序性 的问题

### 编译器和处理器对指令做重排序

从java源代码到执行，会经历三种重排序。

1. 编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序，
2. 指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP)来讲多条指令叠加执行。如果不存在数据依赖，处理器可以改变语句对应机器指令的执行顺序。
3. 内存系统的重排序。由于处理器使用缓存读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。

上述，1 点属于编译器优化，2、3两点属于处理器重排序

JMM（java内存模型）
-------------

JMM本质上可以理解为，Java内存模型规范了JVM如何提供按需禁用缓存和编译优化的方法。

* volatile、synchronized与final三个关键字
* Happens-before 规则

可见性、原子性与有序性

* 原子性

在Java中，对基本数据类型的变量的读取和赋值操作是原子操作，即操作是不可被中断的。只有简单的读取和赋值（不包括变量之间的赋值）// 更大范围的原子性需要synchronized和Lock来实现。

* 可见性

Java提供volatile关键字来保证变量的可见性 。当一个共享变量被volatile关键字修饰时，会保证修改的值会立即被更新到主存，当其他线程需要读时，它会去主存中读取新值。

普通共享变量被修改后，什么时候被写入主存是不确定的，通过synchronized和Lock也可以保证可见性。

* 有序性

在Java里面，可以通过volatile关键字来保证一定的“有序性”。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。当然JMM是通过Happens-Before 规则来保证有序性的。 

AQS 原理

https://www.cnblogs.com/waterystone/p/4920797.html